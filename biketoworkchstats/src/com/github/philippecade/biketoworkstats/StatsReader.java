package com.github.philippecade.biketoworkstats;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.attribute.FileTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import com.github.philippecade.biketoworkstats.model.HistoricalData;
import com.github.philippecade.biketoworkstats.model.HistorizedMember;
import com.github.philippecade.biketoworkstats.model.HistorizedTeam;
import com.github.philippecade.biketoworkstats.model.Member;
import com.github.philippecade.biketoworkstats.model.Team;

/**
 * Reader for the Excel file generated by biketowork.ch.
 * @author XPHC
 */
class StatsReader {

	private static final int MEMBER_1_FIRST_NAME = 8;
	private static final int MEMBER_1_LAST_NAME = 9;
	private static final int MEMBER_1_EMAIL = 10;
	private static final int MEMBER_1_TEAM_NAME = 14;
	private static final int MEMBER_1_BIKE_DAYS = 21;
	private static final int MEMBER_1_NON_BIKE_DAYS = 22;
	private static final int MEMBER_1_TOTAL_KM = 24;

	private static final int MAX_COLUMNS = 25;
	
	/**
	 * Reads the status file and returns the data model
	 * @param file
	 * @return
	 * @throws IOException
	 */
	List<Team> readStatusFile(File file) throws IOException {
		List<Team> teams = new ArrayList<>();
		List<Member> members = new ArrayList<>();
		try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8))) {
			// skip the first header line
			String line = reader.readLine();
			while ((line = reader.readLine()) != null) {
				String[] columns = split(line);
				if (columns.length < MAX_COLUMNS) {
					continue;
				}
				
				members.add(getMember(columns));
			}
		}
		
		members.sort((m1, m2) -> m1.getTeamName().compareTo(m2.getTeamName()));
		Team team = null;
		for (Member m: members) {
			if (team == null || !team.getName().equals(m.getTeamName())) {
				team = new Team(m.getTeamName());
				teams.add(team);
			}
			team.addMember(m);
			team.setKm(team.getKm()+m.getKm());
			team.setBikeDays(team.getBikeDays()+m.getBikeDays(), team.getNonBikeDays()+m.getNonBikeDays());
		}

		return teams;
	}
	
	/**
	 * Reads several status files and returns a historized model
	 * @param files
	 * @return
	 * @throws IOException
	 */
	List<HistorizedTeam> readStatusFiles(File...files) throws IOException {
		List<HistorizedTeam> teams = new ArrayList<>();
		for (File file: files) {
			try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8))) {
				// skip the first header line
				String line = reader.readLine();
				while ((line = reader.readLine()) != null) {
					String[] columns = split(line);
					if (columns.length < MAX_COLUMNS) {
						continue;
					}
					Date timestamp = getTimeStamp(file);
					HistorizedTeam team = getTeam(teams, columns[MEMBER_1_TEAM_NAME]);
					
					getHistorizedMember(team, timestamp, columns);
				}
			}
		}
		
		List<HistorizedMember> members = teams.stream().map(HistorizedTeam::getMembers).flatMap(Collection::stream)
				.collect(Collectors.toList());
		for (HistorizedMember member: members) {
			for (HistoricalData data: member.getData()) {
				// assumes all member's time stamps are synchronized
				Date timestamp = data.getTimestamp(); 
				HistorizedTeam team = getTeam(teams, member.getTeamName());
				team.addKmAndBikeDays(timestamp, data.getKm(), data.getBikeDays(), data.getNonBikeDays());
			}
		}
		return teams;
	}

	private Date getTimeStamp(File file) throws IOException {
		Path path = file.toPath();
		BasicFileAttributes attributes = Files.readAttributes(path, BasicFileAttributes.class);
		FileTime fileTime = attributes.creationTime();
		return new Date(fileTime.toMillis());
	}

	private HistorizedMember getHistorizedMember(HistorizedTeam team, Date timestamp, String[] columns) {
		HistorizedMember member = getMember(team, columns);
		String km = columns[MEMBER_1_TOTAL_KM];
		int nBikeDays = Integer.parseInt(columns[MEMBER_1_BIKE_DAYS]);
		int nNonBikeDays = Integer.parseInt(columns[MEMBER_1_NON_BIKE_DAYS]);
		member.addKmAndBikeDays(timestamp, km.isEmpty() ? 0 : Double.parseDouble(km), nBikeDays, nNonBikeDays);
		return member;
	}
	
	/**
	 * Returns the team matching the given name in the list or create a new one
	 * @param teams
	 * @param teamName
	 * @return
	 */
	private HistorizedTeam getTeam(List<HistorizedTeam> teams, String teamName) {
		Optional<HistorizedTeam> optional = teams.stream().filter(t->teamName.equals(t.getName())).findFirst();
		if (optional.isPresent()) {
			return optional.get();
		}
		HistorizedTeam team = new HistorizedTeam(teamName);
		teams.add(team);
		return team;
	}
	
	private HistorizedMember getMember(HistorizedTeam team, String[] columns) {
		Optional<HistorizedMember> optional = team.getMember(columns[MEMBER_1_EMAIL]);
		if (optional.isPresent()) {
			return optional.get();
		}

		HistorizedMember historizedMember = new HistorizedMember(
				columns[MEMBER_1_FIRST_NAME] + " " + columns[MEMBER_1_LAST_NAME], columns[MEMBER_1_EMAIL]);
		historizedMember.setTeamName(columns[MEMBER_1_TEAM_NAME]);
		team.addMember(historizedMember);
		return historizedMember;
	}

	/**
	 * Returns a member
	 * @param columns
	 * @param emailIndex
	 * @param totalKmIndex
	 * @param daysPerBike
	 * @return
	 */
	Member getMember(String[] columns) {
		Member member = new Member();
		member.setEmail(columns[MEMBER_1_EMAIL]);
		member.setName(columns[MEMBER_1_FIRST_NAME]+" "+columns[MEMBER_1_LAST_NAME]);
		member.setTeamName(columns[MEMBER_1_TEAM_NAME]);
		String km = columns[MEMBER_1_TOTAL_KM];
		if (!km.isEmpty()) {
			double totalKm = Double.parseDouble(km);
			member.setKm(totalKm);
		}
		int nBikeDays = Integer.parseInt(columns[MEMBER_1_BIKE_DAYS]);
		int nNonBikeDays = Integer.parseInt(columns[MEMBER_1_NON_BIKE_DAYS]);
		member.setBikeDays(nBikeDays, nNonBikeDays);
		return member;
	}
	

	private String[] split(String line) {
		return Arrays.stream(line.split(";")).map(this::stripQuotes).toArray(String[]::new);
	}
	
	private String stripQuotes(String s) {
		String result = s;
		if (result.startsWith("\"")) {
			result = result.substring(1);
		}
		if (result.endsWith("\"")) {
			result = result.substring(0, result.length()-1);
		}
		return result;
	}
	
}
